import { describe, expect, it } from "bun:test";
import { readFileSync } from "node:fs";
import { join } from "node:path";
import {
  extractNumber,
  extractTime,
  parseOcrText,
  preprocessLine,
} from "./parser.ts";

const FIXTURES = join(import.meta.dir, "../../../tests/fixtures");

function loadFixture(name: string): string {
  return readFileSync(join(FIXTURES, name), "utf-8");
}

function loadJson(name: string): Record<string, number> {
  return JSON.parse(readFileSync(join(FIXTURES, name), "utf-8"));
}

// --- Unit tests ---

describe("preprocessLine", () => {
  it("strips trailing pipe", () => {
    expect(preprocessLine("TOTAL XP 5,073,982 al v3 |")).toBe(
      "TOTAL XP 5,073,982 al v3",
    );
  });

  it("strips character model noise before pipe", () => {
    expect(preprocessLine("2 Sa— | MELEE KILLS 37,014 oS")).toBe(
      "MELEE KILLS 37,014 oS",
    );
  });

  it("handles bracket instead of pipe", () => {
    expect(preprocessLine("[SHotsEReD 2,764,314 #4 #44")).toBe(
      "SHotsEReD 2,764,314 #4 #44",
    );
  });

  it("handles multiple pipes (takes after last)", () => {
    expect(preprocessLine("| 0 | | SUPPLY STRATS ~~ 13,547 al #7")).toBe(
      "SUPPLY STRATS ~~ 13,547 al #7",
    );
  });
});

describe("extractNumber", () => {
  it("parses comma-separated numbers", () => {
    expect(extractNumber("761,798 #l #22")).toBe(761798);
  });

  it("handles tilde noise", () => {
    expect(extractNumber("~~ 349,050 #2 #32")).toBe(349050);
  });

  it("handles numbers without commas", () => {
    expect(extractNumber("22351 #4 #33")).toBe(22351);
  });

  it("returns null for no number", () => {
    expect(extractNumber("no numbers here")).toBeNull();
  });
});

describe("extractTime", () => {
  it("parses short time", () => {
    expect(extractTime("0:06:02 #58 #912")).toBe(362);
  });

  it("parses long time", () => {
    expect(extractTime("1093:15:44 #2 wd?")).toBe(3935744);
  });

  it("returns null for no time", () => {
    expect(extractTime("12345 #1")).toBeNull();
  });
});

// --- Integration tests against real OCR fixtures ---
//
// NOTE: sample-extracted-stats.json and sample-extracted-stats-2.json were
// generated by running the parser on the OCR output fixtures. These values
// should be independently verified against the original game screenshots.
// Until verified, these tests prove consistency (parser produces same output
// for same input), not correctness (parser produces correct output).

const EXPECTED_STAT_KEYS = [
  "automatonKills",
  "deaths",
  "defensiveStratagems",
  "eagleKills",
  "eagleStratagems",
  "enemyKills",
  "friendlyKills",
  "grenadeKills",
  "illuminateKills",
  "inMissionTimeSeconds",
  "meleeKills",
  "missionsPlayed",
  "missionsWon",
  "objectivesCompleted",
  "orbitalsUsed",
  "samplesCollected",
  "shotsFired",
  "shotsHit",
  "supplyStratagems",
  "terminidKills",
  "totalXp",
];

describe("parseOcrText — card 1 (THUPER)", () => {
  const ocrText = loadFixture("sample-ocr-output.txt");
  const expected = loadJson("sample-extracted-stats.json");
  const result = parseOcrText(ocrText);

  it("extracts exactly the expected stat keys", () => {
    expect(Object.keys(result.stats).sort()).toEqual(EXPECTED_STAT_KEYS);
  });

  it("matches every expected value", () => {
    for (const [key, value] of Object.entries(expected)) {
      expect(result.stats[key as keyof typeof result.stats]).toBe(value);
    }
  });

  it("extracts player name", () => {
    expect(result.playerName).toBe("THUPER");
  });

  it("uses label confidence for at least 20 of 21 stats", () => {
    const labelCount = Object.values(result.confidence).filter(
      (c) => c === "label",
    ).length;
    // Card 1 has high-quality OCR — at least 20 labels match
    expect(labelCount).toBeGreaterThanOrEqual(20);
    expect(labelCount).toBeLessThanOrEqual(21);
  });
});

describe("parseOcrText — card 2 (GAMBLE)", () => {
  const ocrText = loadFixture("sample-ocr-output-2.txt");
  const expected = loadJson("sample-extracted-stats-2.json");
  const result = parseOcrText(ocrText);

  it("extracts exactly the expected stat keys", () => {
    expect(Object.keys(result.stats).sort()).toEqual(EXPECTED_STAT_KEYS);
  });

  it("matches every expected value", () => {
    for (const [key, value] of Object.entries(expected)) {
      expect(result.stats[key as keyof typeof result.stats]).toBe(value);
    }
  });

  it("extracts player name", () => {
    expect(result.playerName).toBe("GAMBLE");
  });

  it("uses label confidence for 20 stats and position for shotsHit", () => {
    const labelCount = Object.values(result.confidence).filter(
      (c) => c === "label",
    ).length;
    const positionCount = Object.values(result.confidence).filter(
      (c) => c === "position",
    ).length;
    expect(labelCount).toBe(20);
    expect(positionCount).toBe(1);
    expect(result.confidence.shotsHit).toBe("position");
  });
});
